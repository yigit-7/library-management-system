import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryKey,
  useInfiniteQuery,
  UseInfiniteQueryOptions,
} from '@tanstack/react-query';
import { CancelablePromise } from '@/lib/api';
import { ApiError } from '@/lib/api';

// Helper to unwrap CancelablePromise
// TanStack Query expects a standard Promise.
// We also handle the cancellation signal from TanStack Query if needed,
// but for simplicity, we just return the promise result.
// If you want to support cancellation, you can hook into the signal.
const unwrap = <T>(promise: CancelablePromise<T>, signal?: AbortSignal): Promise<T> => {
  if (signal) {
    signal.addEventListener('abort', () => {
      promise.cancel();
    });
  }
  return promise as unknown as Promise<T>;
};

// Generic type for API functions
type ApiFunction<TData, TArgs extends unknown[]> = (...args: TArgs) => CancelablePromise<TData>;

/**
 * A wrapper for useQuery that works with CancelablePromise.
 * 
 * @param key The query key.
 * @param apiFn The API function generated by openapi-typescript-codegen.
 * @param args The arguments to pass to the API function.
 * @param options Additional options for useQuery.
 */
export function useApiQuery<TData, TArgs extends unknown[]>(
  key: QueryKey,
  apiFn: ApiFunction<TData, TArgs>,
  args: TArgs,
  options?: Omit<UseQueryOptions<TData, ApiError>, 'queryKey' | 'queryFn'>
) {
  return useQuery<TData, ApiError>({
    queryKey: key,
    queryFn: ({ signal }) => unwrap(apiFn(...args), signal),
    ...options,
  });
}

/**
 * A wrapper for useMutation that works with CancelablePromise.
 * 
 * @param apiFn The API function generated by openapi-typescript-codegen.
 * @param options Additional options for useMutation.
 */
export function useApiMutation<TData, TArgs extends unknown[]>(
  apiFn: ApiFunction<TData, TArgs>,
  options?: Omit<UseMutationOptions<TData, ApiError, TArgs>, 'mutationFn'>
) {
  return useMutation<TData, ApiError, TArgs>({
    mutationFn: (args: TArgs) => unwrap(apiFn(...(Array.isArray(args) ? args : [args]) as TArgs)),
    ...options,
  });
}

// Special case for mutations that take a single object argument (common in POST/PUT)
// This avoids the need to wrap the argument in an array when calling mutate.
export function useApiMutationSingle<TData, TArg>(
  apiFn: (arg: TArg) => CancelablePromise<TData>,
  options?: Omit<UseMutationOptions<TData, ApiError, TArg>, 'mutationFn'>
) {
  return useMutation<TData, ApiError, TArg>({
    mutationFn: (arg: TArg) => unwrap(apiFn(arg)),
    ...options,
  });
}

// Example usage:
// const { data } = useApiQuery(['books'], BookControllerService.getBooks, []);
// const { mutate } = useApiMutationSingle(BookControllerService.createBook);
